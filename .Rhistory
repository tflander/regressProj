yn <- (y - mean(y)) / sd(y)
xn <- (x - mean(x)) / sd(x)
cor(y,x)
cor(yn,xn)
lm(yn~xn)
data(diamond)
y <- diamond$price
x <- diamond$carat
n <- length(y)
fit <- lm(y ~ x)
e <- resid(fit)
yhat <- predict(fit)
max(abs(e -(y - yhat)))
library(UsingR)
data(diamond)
y <- diamond$price
x <- diamond$carat
n <- length(y)
fit <- lm(y ~ x)
e <- resid(fit)
yhat <- predict(fit)
max(abs(e -(y - yhat)))
sum(e)
plot(x, e,
xlab = "Mass (carats)",
ylab = "Residuals (SIN $)",
bg = "lightblue",
col = "black", cex = 2, pch = 21,frame = FALSE)
abline(h = 0, lwd = 2)
for (i in 1 : n)
lines(c(x[i], x[i]), c(e[i], 0), col = "red" , lwd = 2)
library(UsingR); data(diamond)
library(ggplot2)
g = ggplot(diamond, aes(x=carat, y=price))
g = g + geom_point(size=6, color="black", alpha=0.2)
g = g + xlab("mass (carats)") + ylab("price singapore $")
g = g + geom_point(size=6, color="black", alpha=0.2)
g = g + geom_point(size=5, color="blue", alpha=0.2)
g = g + geom_smooth(method="lm", color="black")
g
library(UsingR); data(diamond)
library(ggplot2)
g = ggplot(diamond, aes(x=carat, y=e))
g = g + geom_point(size=6, color="black", alpha=0.2)
g = g + xlab("mass (carats)") + ylab("Residuals (SIN $)")
g = g + geom_point(size=6, color="black", alpha=0.2)
g = g + geom_point(size=5, color="blue", alpha=0.2)
g = g + geom_smooth(method="lm", color="black")
g
?geom_abline
library(UsingR); data(diamond)
library(ggplot2)
g = ggplot(diamond, aes(x=carat, y=e))
g = g + geom_point(size=6, color="black", alpha=0.2)
g = g + xlab("mass (carats)") + ylab("Residuals (SIN $)")
g = g + geom_point(size=6, color="black", alpha=0.2)
g = g + geom_point(size=5, color="blue", alpha=0.2)
g = g + geom_abline(intercept=0, slope=0)
g
library(UsingR); data(diamond)
library(ggplot2)
g = ggplot(diamond, aes(x=carat, y=e))
g = g + geom_point(size=6, color="black", alpha=0.2)
g = g + xlab("mass (carats)") + ylab("Residuals (SIN $)")
g = g + geom_point(size=6, color="black", alpha=0.2)
g = g + geom_point(size=5, color="blue", alpha=0.2)
g = g + geom_abline(intercept=0, slope=0)
for (i in 1 : n) {
g = g + geom_abline(c(x[i], x[i]), c(e[i], 0))
#lines(c(x[i], x[i]), c(e[i], 0), col = "red" , lwd = 2)
}
g
?geom_abline
library(UsingR); data(diamond)
library(ggplot2)
g = ggplot(diamond, aes(x=carat, y=e))
g = g + geom_point(size=6, color="black", alpha=0.2)
g = g + xlab("mass (carats)") + ylab("Residuals (SIN $)")
g = g + geom_point(size=6, color="black", alpha=0.2)
g = g + geom_point(size=5, color="blue", alpha=0.2)
g = g + geom_abline(intercept=0, slope=0)
for (i in 1 : n) {
g = g + geom_line(c(x[i], x[i]), c(e[i], 0))
#lines(c(x[i], x[i]), c(e[i], 0), col = "red" , lwd = 2)
}
g
?geom_line
g = ggplot(diamond, aes(x=carat, y=e))
g = g + geom_point(size=6, color="black", alpha=0.2)
g = g + xlab("mass (carats)") + ylab("Residuals (SIN $)")
g = g + geom_point(size=6, color="black", alpha=0.2)
g = g + geom_point(size=5, color="blue", alpha=0.2)
g = g + geom_abline(intercept=0, slope=0)
g
g = ggplot(diamond, aes(x=carat, y=e))
g = g + geom_point(size=6, color="black", alpha=0.2)
g = g + xlab("mass (carats)") + ylab("Residuals (SIN $)")
g = g + geom_point(size=6, color="black", alpha=0.2)
g = g + geom_point(size=5, color="blue", alpha=0.2)
g = g + geom_abline(intercept=0, slope=0)
g = g + geom_line(x=x, y=e)
g
x = runif(100, -3, 3); y = x + sin(x) + rnorm(100, sd = .2);
library(ggplot2)
g = ggplot(data.frame(x = x, y = y), aes(x = x, y = y))
g = g + geom_smooth(method = "lm", colour = "black")
g = g + geom_point(size = 7, colour = "black", alpha = 0.4)
g = g + geom_point(size = 5, colour = "red", alpha = 0.4)
g
g = ggplot(data.frame(x = x, y = resid(lm(y ~ x))),
aes(x = x, y = y))
g = g + geom_hline(yintercept = 0, size = 2);
g = g + geom_point(size = 7, colour = "black", alpha = 0.4)
g = g + geom_point(size = 5, colour = "red", alpha = 0.4)
g = g + xlab("X") + ylab("Residual")
g
x <- runif(100, 0, 6); y <- x + rnorm(100,  mean = 0, sd = .001 * x);
g = ggplot(data.frame(x = x, y = y), aes(x = x, y = y))
g = g + geom_smooth(method = "lm", colour = "black")
g = g + geom_point(size = 7, colour = "black", alpha = 0.4)
g = g + geom_point(size = 5, colour = "red", alpha = 0.4)
g
g = ggplot(data.frame(x = x, y = resid(lm(y ~ x))),
aes(x = x, y = y))
g = g + geom_hline(yintercept = 0, size = 2);
g = g + geom_point(size = 7, colour = "black", alpha = 0.4)
g = g + geom_point(size = 5, colour = "red", alpha = 0.4)
g = g + xlab("X") + ylab("Residual")
g
e = c(resid(lm(price ~ 1, data = diamond)),
resid(lm(price ~ carat, data = diamond)))
fit = factor(c(rep("Itc", nrow(diamond)),
rep("Itc, slope", nrow(diamond))))
g = ggplot(data.frame(e = e, fit = fit), aes(y = e, x = fit, fill = fit))
g = g + geom_dotplot(binaxis = "y", size = 2, stackdir = "center", binwidth = 20)
g = g + xlab("Fitting approach")
g = g + ylab("Residual price")
g
y <- diamond$price; x <- diamond$carat; n <- length(y)
fit <- lm(y ~ x)
summary(fit)$sigma
sqrt(sum(resid(fit)^2) / (n - 2))
summary(fit)
fitp <- lm(price~1, diamond)
summary(fitp)
mean(diamond$price)
plot(diamond$price)
hist(diamond$price)
data(anscombe);example(anscombe)
a <- c(0,0,0,0,0,1,1,1,1,1)
mean(a)
sd(a)
var(a)
a
library(UsingR); data(diamond)
y <- diamond$price; x <- diamond$carat; n <- length(y)
beta1 <- cor(y, x) * sd(y) / sd(x)
beta0 <- mean(y) - beta1 * mean(x)
e <- y - beta0 - beta1 * x # residuals
sigma <- sqrt(sum(e^2) / (n-2)) # sigma from the regression using residuals
ssx <- sum((x - mean(x))^2) # denominator of the slope variance calculation
seBeta0 <- (1 / n + mean(x) ^ 2 / ssx) ^ .5 * sigma
seBeta1 <- sigma / sqrt(ssx)
# the two t-statistics for hypothesis testing
tBeta0 <- beta0 / seBeta0
tBeta1 <- beta1 / seBeta1
pBeta0 <- 2 * pt(abs(tBeta0), df = n - 2, lower.tail = FALSE)
pBeta1 <- 2 * pt(abs(tBeta1), df = n - 2, lower.tail = FALSE)
coefTable <- rbind(c(beta0, seBeta0, tBeta0, pBeta0), c(beta1, seBeta1, tBeta1, pBeta1))
colnames(coefTable) <- c("Estimate", "Std. Error", "t value", "P(>|t|)")
rownames(coefTable) <- c("(Intercept)", "x")
coefTable
fit <- lm(y ~ x)
summary(fit)$coefficients
sumCoef <- summary(fit)$coefficients
sumCoef[1,1] + c(-1, 1) * qt(.975, df = fit$df) * sumCoef[1, 2]
summary(fit)
fit <- lm(mpg~wt, mtcars)
sumCoef[1,1] + c(-1, 1) * qt(.975, df = fit$df) * sumCoef[1, 2]
y <- mtcars$mpg
x <- mtcars$wt
fit <- lm(y~x)
sumCoef <- summary(fit)$coefficients
sumCoef[2,1] + c(-1, 1) * qt(.975, df = fit$df) * sumCoef[2, 2]
fit <- lm(mpg~wt, mtcars)
sumCoef <- summary(fit)$coefficients
sumCoef[1,1] + c(-1, 1) * qt(.975, df = fit$df) * sumCoef[1, 2]
summary(fit)
sumCoef[2,1] + c(-1, 1) * qt(.975, df = fit$df) * sumCoef[2, 2]
fit <- lm(price~carat, data=diamond)
sumCoef <- summary(fit)$coefficients
# the 95% confidence interval of the intercept
sumCoef[1,1] + c(-1, 1) * qt(.975, df = fit$df) * sumCoef[1, 2]
sumCoef[2,1] + c(-1, 1) * qt(.975, df = fit$df) * sumCoef[2, 2]
library(UsingR)
y <- galton$child
x <- galton$parent
yn <- (y - mean(y))/sd(y)
xn <- (x - mean(x))/sd(x)
c(cor(y,x), cor(yn,xn), lm(yn ~ xn)$coef[2], lm(xn ~ yn)$coef[2], lm(yn ~ xn - 1)$coef, lm(xn ~ yn -1)$coef)
lm(yn ~ xn)
lm(xn ~ yn)
lm(x~y)
lm(y~x)
plot(xn,yn)
abline(lm(yn~xn))
abline(lm(xn~yn))
plot(x,y)
abline(lm(y~x))
abline(lm(x~y))
x <- runif(100)
y <- rnorm(100, sd=0.2) + 2*x
yn <- (y - mean(y))/sd(y)
xn <- (x - mean(x))/sd(x)
c(cor(y,x), cor(yn,xn), lm(yn ~ xn)$coef[2], lm(xn ~ yn)$coef[2], lm(yn ~ xn - 1)$coef, lm(xn ~ yn -1)$coef)
plot(xn,yn)
abline(lm(y~x))
abline(lm(x~y))
plot(xn,yn)
abline(lm(yn~xn))
abline(lm(xn~yn))
lm(yn~xn)
lm(xn~yn)
library(ggplot2)
newx = data.frame(x = seq(min(x), max(x), length = 100))
p1 = data.frame(predict(fit, newdata= newx,interval = ("confidence")))
p2 = data.frame(predict(fit, newdata = newx,interval = ("prediction")))
p1$interval = "confidence"
p2$interval = "prediction"
p1$x = newx$x
p2$x = newx$x
dat = rbind(p1, p2)
names(dat)[1] = "y"
g = ggplot(dat, aes(x = x, y = y))
g = g + geom_ribbon(aes(ymin = lwr, ymax = upr, fill = interval), alpha = 0.2)
g = g + geom_line()
g = g + geom_point(data = data.frame(x = x, y=y), aes(x = x, y = y), size = 4)
g
library(ggplot2)
library(UsingR); data(diamond)
y <- diamond$price; x <- diamond$carat; n <- length(y)
newx = data.frame(x = seq(min(x), max(x), length = 100))
p1 = data.frame(predict(fit, newdata= newx,interval = ("confidence")))
p2 = data.frame(predict(fit, newdata = newx,interval = ("prediction")))
p1$interval = "confidence"
p2$interval = "prediction"
p1$x = newx$x
p2$x = newx$x
dat = rbind(p1, p2)
names(dat)[1] = "y"
g = ggplot(dat, aes(x = x, y = y))
g = g + geom_ribbon(aes(ymin = lwr, ymax = upr, fill = interval), alpha = 0.2)
g = g + geom_line()
g = g + geom_point(data = data.frame(x = x, y=y), aes(x = x, y = y), size = 4)
g
library(ggplot2)
library(UsingR); data(diamond)
y <- diamond$price; x <- diamond$carat; n <- length(y)
newx = data.frame(x = seq(min(x), max(x), length = 100))
fit <- lm(y~x)
p1 = data.frame(predict(fit, newdata= newx,interval = ("confidence")))
p2 = data.frame(predict(fit, newdata = newx,interval = ("prediction")))
p1$interval = "confidence"
p2$interval = "prediction"
p1$x = newx$x
p2$x = newx$x
dat = rbind(p1, p2)
names(dat)[1] = "y"
g = ggplot(dat, aes(x = x, y = y))
g = g + geom_ribbon(aes(ymin = lwr, ymax = upr, fill = interval), alpha = 0.2)
g = g + geom_line()
g = g + geom_point(data = data.frame(x = x, y=y), aes(x = x, y = y), size = 4)
g
predict(fit, newdata= newx,interval = ("confidence"))
predict(fit, newdata= mean(x),interval = ("confidence"))
predict(fit, newdata= c(mean(x)),interval = ("confidence"))
predict(fit, newdata= mean(x),interval = ("confidence"))
mean(x)
predict(fit, newdata=1000,interval = ("confidence"))
fit
predict(fit, newdata=c(1000),interval = ("confidence"))
predict(fit, newdata=newx,interval = ("confidence"))
newx
?predict
fit <- lm(mpg~wt, data=mtcars)
sumCoef <- summary(fit)$coefficients
sumCoef
sumCoef[1,1]
sumCoef[1,2]
predict(fit, interval = ("prediction"))
?predict
min(mtcars$wt)
max(mtcars$wt)
newx = data.frame(x = seq(2, 5, length = 100))
newx
predict(fit, newx=newx, interval = ("prediction")) # the default
predict(fit, newdata=newx, interval = ("prediction"))
View(newx)
newx = data.frame(x = seq(2, 5, length = 100))
names(newx) <- "wt"
predict(fit, newdata=newx, interval = ("prediction"))
newx
newx$wt==3
match(newx,3)
newx[34]
newx
match(newx$wt,3)
pmatch(newx$wt,3)
newx$wt==3
which(newx$wt==3)
fit <- lm(mpg~wt, data=mtcars)
newx = data.frame(x = seq(2, 5, length = 100))
names(newx) <- "wt"
i <- which(newx$wt==3)
p <- predict(fit, newdata=newx, interval = ("prediction"))
p[i]
p[i,]
fit <- lm(mpg~wt, data=mtcars)
sumCoef <- summary(fit)$coefficients
# the 95% confidence interval of the intercept (mpg of a zero weight car)
sumCoef[1,1] + c(-1, 1) * qt(.975, df = fit$df) * sumCoef[1, 2]
sumCoef[2,1] + c(-1, 1) * qt(.975, df = fit$df) * sumCoef[2, 2]
fit2 <- lm(mpg~I(wt*2), data=mtcars)
fit2
summary(fit2)
summary(fit)
fit2 <- lm(mpg~I(wt/2), data=mtcars)
summary(fit2)
fit2 <- lm(mpg~I(wt/2), data=mtcars)
sumCoef2 <- summary(fit2)$coefficients
sumCoef2[2,1] + c(-1, 1) * qt(.975, df = fit2$df) * sumCoef2[2, 2]
fit <- lm(mpg~wt, data=mtcars)
fit2 <- lm(mpg~I(wt+2), data=mtcars)
summary(fit)
summary(fit2)
fit <- lm(mpg~wt, data=mtcars)
summary(fit)
n <- length(mtcars$mpg)
beta1 <- cor(y, x) * sd(y) / sd(x)
beta0 <- mean(y) - beta1 * mean(x)
e <- y - beta0 - beta1 * x # residuals
sigma <- sqrt(sum(e^2) / (n-2)) # sigma from the regression using residuals
ssx <- sum((x - mean(x))^2) # denominator of the slope variance calculation
seBeta0 <- (1 / n + mean(x) ^ 2 / ssx) ^ .5 * sigma
seBeta1 <- sigma / sqrt(ssx)
x <- mtcars$wt
y <- mtcars$mpg
n <- length(x)
fit <- lm(mpg~wt, data=mtcars)
beta1 <- cor(y, x) * sd(y) / sd(x)
beta0 <- mean(y) - beta1 * mean(x)
e <- y - beta0 - beta1 * x # residuals
sigma <- sqrt(sum(e^2) / (n-2)) # sigma from the regression using residuals
ssx <- sum((x - mean(x))^2) # denominator of the slope variance calculation
seBeta0 <- (1 / n + mean(x) ^ 2 / ssx) ^ .5 * sigma
seBeta1 <- sigma / sqrt(ssx)
fit <- lm(mpg~wt, mtcars)
newx = data.frame(x = seq(2, 5, length = 100))
names(newx) <- "wt"
avgWt <- mean(mtcars$wr)
avgWt <- mean(mtcars$wt)
newx
newx = data.frame(x = seq(2, 5, length = 200))
names(newx) <- "wt"
newx
newx = data.frame(x = seq(2, 5, length = 1000))
names(newx) <- "wt"
newx
p <- predict(fit, newdata=newx, interval = ("prediction"))
p[406,]
p[407,]
p[408,]
?predict
p <- predict(fit, newdata=newx, interval = ("confidence"))
p[406,]
x <- mtcars$wt
y <- mtcars$mpg
n <- length(x)
fit <- lm(mpg~wt, data=mtcars)
beta1 <- cor(y, x) * sd(y) / sd(x)
beta0 <- mean(y) - beta1 * mean(x)
e <- y - beta0 - beta1 * x # residuals
sigma <- sqrt(sum(e^2) / (n-2)) # sigma from the regression using residuals
ssx <- sum((x - mean(x))^2) # denominator of the slope variance calculation
seBeta0 <- (1 / n + mean(x) ^ 2 / ssx) ^ .5 * sigma
seBeta1 <- sigma / sqrt(ssx)
summary(fit)
fit <- lm(mpg~wt-1, data=mtcars)
beta1 <- cor(y, x) * sd(y) / sd(x)
beta0 <- mean(y) - beta1 * mean(x)
e <- y - beta0 - beta1 * x # residuals
sigma <- sqrt(sum(e^2) / (n-2)) # sigma from the regression using residuals
ssx <- sum((x - mean(x))^2) # denominator of the slope variance calculation
fit <- lm(mpg~wt, data=mtcars)
fit1 <- lm(mpg~wt-1, data=mtcars)
summary(fit)
summary(fit1)
coef(fit)
coef(fit)[1]
coef(fit)[2]
beta1 <- coef(fit)[2]
beta0 <- coef(fit)[1]
fit$residuals
summary(fit)
summary(e)
resid(fit)
summary(resid(fit))
fit <- lm(mpg~wt-1, data=mtcars)
beta1 <- coef(fit)[2] # cor(y, x) * sd(y) / sd(x)
beta0 <- coef(fit)[1] # mean(y) - beta1 * mean(x)
e <- resid(fit) # y - beta0 - beta1 * x # residuals
sigma <- sqrt(sum(e^2) / (n-2)) # sigma from the regression using residuals
ssx <- sum((x - mean(x))^2) # denominator of the slope variance
fit <- lm(mpg~wt, data=mtcars)
#fit <- lm(mpg~wt-1, data=mtcars)
beta1 <- coef(fit)[2] # cor(y, x) * sd(y) / sd(x)
beta0 <- coef(fit)[1] # mean(y) - beta1 * mean(x)
e <- resid(fit) # y - beta0 - beta1 * x # residuals
sigma <- sqrt(sum(e^2) / (n-2)) # sigma from the regression using residuals
# sigma with intercept =
# sigma without intercept = 11.4552
ssx <- sum((x - mean(x))^2) # denominator of the slope variance calculation
# ssx with or without intercept = 29.6787
summary(fit)
summary(fit1)
lm(mpg~1)
lm(mpg~1, data=mtcars)
fit <- lm(mpg~1, data=mtcars)
beta1 <- coef(fit)[2] # cor(y, x) * sd(y) / sd(x)
beta0 <- coef(fit)[1] # mean(y) - beta1 * mean(x)
e <- resid(fit) # y - beta0 - beta1 * x # residuals
sigma <- sqrt(sum(e^2) / (n-2)) # sigma from the regression using residuals
# sigma with intercept = 3.0459
# sigma without intercept = 11.4552
ssx <- sum((x - mean(x))^2) # denominator of the slope variance calculation
# ssx with or without intercept = 29.6787
fit <- lm(mpg~wt, data=mtcars)
fit1 <- lm(mpg~1, data=mtcars)
fit2 <- lm(mpg~wt-1, data=mtcars)
sum(resid(fit)^2)
sum(resid(fit1)^2)
sum(resid(fit2)^2)
sum(resid(fit)^2)/sum(resid(fit1)^2)
fit <- lm(mpg~wt, data=mtcars)
fit1 <- lm(mpg~1, data=mtcars)
sum(resid(fit)^2)/sum(resid(fit1)^2)
setwd("/common/coursera/modelingRegressionTakeTwo/project")
source("coors.R")
View(bestRSquared)
a <- mtcars$mpg ~ mtcars~wt
lm(a)
a <- mtcars$mpg ~ mtcars$wt
lm(a)
lm(mpg~wt)
lm(mpg~wt, data=mtcars)
?mtcars
?lm
mtcars["mpg"]
source("coors.R")
predictor = "cyl"
mtcars[predictor]
lm(mtcars$mpg ~ mtcars[predictor])
lm(mtcars$mpg ~ mtcars[predictor][1])
lm(mtcars$mpg ~ mtcars[predictor])
class(mtcars$mpg)
class(mtcars[predictor])
class(mtcars[predictor,])
class(mtcars[predictor][0])
class(mtcars[predictor][1])
class(mtcars[predictor,])
class(mtcars[predictor])
a <- class(mtcars[predictor])
View(a)
mtcars[predictor]
a <- mtcars[predictor]
class(a)
class(a[1])
class(a$cyl)
class(a[1,1])
a[1,1]
a[1,1:length(a)]
a
length(a)
a[1,1:nrow(a)]
a[1:nrow(a),1]
class(a[1:nrow(a),1])
a[,1]
source(coors.R)
source("coors.R")
View(bestRSquared)
source("coors.R")
names(fitAll$model)[2]
source("coors.R")
View(bestRSquared)
source("coors.R")
View(bestRSquared)
summary(lm(mpg~wt, data=mtcars))
summary(lm(mpg~wt, data=manual))
summary(lm(mpg~wt, data=automatic))
source("coors.R")
View(bestRSquared)
sessionInfo()
x <- rnorm(100)
y <- rnorm(100)
fit <- lm(y~x)
fit <- lm(mpg~wt,data=mtcars)
summary(fit)$coefficients
summary(fit)$coefficients[1,4]
summary(fit)$coefficients[2,4]
source("coors.R")
View(bestRSquared)
setwd("/common/coursera/modelingRegressionTakeTwo/project")
